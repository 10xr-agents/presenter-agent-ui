# Cursor Project Rules

**⚠️ CRITICAL: Always follow the rules in RULESETS.md when generating code to prevent build and lint errors.**

This project has mandatory code patterns documented in `RULESETS.md`. These rules prevent known build issues and ensure code compatibility with our tech stack.

## Quick Reference

Before generating ANY code, check these mandatory patterns:

### 1. Error Handling (Catch Blocks)
**MANDATORY**: Always type catch block errors as `unknown`

```typescript
// ❌ WRONG
catch (error) {
  console.error(error.message)
}

// ✅ CORRECT
catch (error: unknown) {
  const message = error instanceof Error ? error.message : String(error)
  console.error(message)
}
```

### 2. Mongoose Model Operations
**MANDATORY**: Always use `(Model as any).method()` pattern

```typescript
// ❌ WRONG
const user = await User.findOne({ email })

// ✅ CORRECT
const user = await (User as any).findOne({ email })
```

**Apply to**: `create()`, `find()`, `findOne()`, `findById()`, `findOneAndUpdate()`, `findByIdAndUpdate()`, `countDocuments()`, `deleteOne()`, `deleteMany()`, `updateOne()`, `updateMany()`

### 3. Zod v4 Validation
**MANDATORY**: Use `.refine()` for URL/email validation, specify key type for `z.record()`

```typescript
// ❌ WRONG
link: z.string().url().optional()
metadata: z.record(z.any()).optional()

// ✅ CORRECT
link: z.string().refine(
  (val) => {
    if (!val) return true
    try {
      new URL(val)
      return true
    } catch {
      return false
    }
  },
  { message: "Invalid URL format" }
).optional()
metadata: z.record(z.string(), z.any()).optional()
```

### 4. JSON Parsing
**MANDATORY**: Always type assert `await request.json()` and `await response.json()`

```typescript
// ❌ WRONG
const body = await request.json()
const { messages, task } = body

// ✅ CORRECT
const body = (await request.json()) as {
  messages?: AgentMessage[]
  task?: string
  organizationId?: string
}
const { messages, task } = body
```

### 5. Better Auth Import Paths
**MANDATORY**: Use `better-auth/client/plugins` for client-side plugins

```typescript
// ❌ WRONG
import { organizationClient } from "better-auth/react/plugins"

// ✅ CORRECT
import { organizationClient } from "better-auth/client/plugins"
```

### 6. JSX in TypeScript Files
**MANDATORY**: Always use `.tsx` extension for files containing JSX

```typescript
// ❌ WRONG - MyComponent.ts
export function MyComponent() {
  return <div>Hello</div>
}

// ✅ CORRECT - MyComponent.tsx
export function MyComponent() {
  return <div>Hello</div>
}
```

### 7. Next.js 16 Middleware
**MANDATORY**: Always use `proxy.ts`, never `middleware.ts`

```typescript
// ❌ WRONG - middleware.ts
export function middleware() { ... }

// ✅ CORRECT - proxy.ts
export function proxy() { ... }
```

### 8. NextRequest IP Address
**MANDATORY**: Extract IP from headers, never use `req.ip`

```typescript
// ❌ WRONG
const ip = req.ip

// ✅ CORRECT
const ip = req.headers.get("x-forwarded-for")?.split(",")[0] || 
           req.headers.get("x-real-ip") || 
           "anonymous"
```

### 9. Stripe API Version
**MANDATORY**: Use API version `"2025-02-24.acacia"` for Stripe

```typescript
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: "2025-02-24.acacia",
})
```

### 10. Lazy Initialization
**MANDATORY**: Use lazy initialization for third-party clients requiring environment variables (Stripe, Redis, etc.)

```typescript
// ❌ WRONG - Fails during build if env var missing
if (!process.env.STRIPE_SECRET_KEY) {
  throw new Error("STRIPE_SECRET_KEY is not set")
}
export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: "2025-02-24.acacia",
})

// ✅ CORRECT - Lazy initialization
let stripeInstance: Stripe | null = null

function getStripe(): Stripe {
  if (!stripeInstance) {
    if (!process.env.STRIPE_SECRET_KEY) {
      throw new Error("STRIPE_SECRET_KEY is not set")
    }
    stripeInstance = new Stripe(process.env.STRIPE_SECRET_KEY, {
      apiVersion: "2025-02-24.acacia",
      typescript: true,
    })
  }
  return stripeInstance
}

export const stripe = new Proxy({} as Stripe, {
  get(_target, prop) {
    return getStripe()[prop as keyof Stripe]
  },
})
```

### 11. Reduce Function Type Annotations
**MANDATORY**: Always type reduce callback parameters explicitly

```typescript
// ❌ WRONG
const total = items.reduce((sum, item) => sum + item.value, 0)

// ✅ CORRECT
const total = items.reduce((sum: number, item: any) => sum + item.value, 0)
```

### 12. Mongoose Document Property Conflicts
**MANDATORY**: Use `Omit<mongoose.Document, "conflictingProperty">` when interface properties conflict

```typescript
// ❌ WRONG
export interface ICost extends mongoose.Document {
  model: string // Conflicts with Document.model
}

// ✅ CORRECT
export interface ICost extends Omit<mongoose.Document, "model"> {
  model: string // Now safe
}
```

### 13. Mongoose Duplicate Index Warnings
**MANDATORY**: Use only one indexing method - either `index: true` OR `Schema.index()`, not both

**IMPORTANT**: `unique: true` automatically creates an index! Do NOT add `Schema.index()` for fields with `unique: true`.

**Prefer `Schema.index()` over `index: true`** for better readability and flexibility (especially for composite indexes).

```typescript
// ❌ WRONG - Duplicate index definition (index: true + Schema.index())
const Schema = new Schema({
  organizationId: { type: String, required: true, index: true }, // Index defined here
  invoiceId: { type: String, index: true }, // Index defined here
})
Schema.index({ organizationId: 1 }) // And here - causes duplicate warning
Schema.index({ invoiceId: 1 }) // And here - causes duplicate warning

// ❌ WRONG - unique: true creates index, Schema.index() creates duplicate
const Schema = new Schema({
  shareableToken: { type: String, required: true, unique: true }, // unique: true creates index automatically
})
Schema.index({ shareableToken: 1 }) // DUPLICATE! unique: true already created the index

// ✅ CORRECT - Use only Schema.index() method
const Schema = new Schema({
  organizationId: { type: String, required: true }, // No index here
  invoiceId: { type: String }, // No index here
})
Schema.index({ organizationId: 1 }) // Only here
Schema.index({ invoiceId: 1 }) // Only here

// ✅ CORRECT - unique: true (no Schema.index() needed)
const Schema = new Schema({
  shareableToken: { type: String, required: true, unique: true }, // unique: true creates index automatically
  organizationId: { type: String, required: true, unique: true }, // unique: true creates index automatically
})
// No Schema.index() calls needed for unique fields

// ✅ CORRECT - Composite indexes (must use Schema.index())
const Schema = new Schema({
  organizationId: { type: String, required: true }, // No index: true
})
Schema.index({ organizationId: 1, status: 1 }) // Composite index
Schema.index({ organizationId: 1, createdAt: -1 }) // Another composite index starting with organizationId
```

**Note**: 
- `unique: true` automatically creates an index - do NOT add `Schema.index()` for the same field
- Composite indexes (indexes on multiple fields) can efficiently serve queries on their prefix fields. For example, an index on `{ organizationId: 1, status: 1 }` can also be used for queries on just `organizationId`, so you don't need a separate single-field index.

### 14. BullMQ Queue Types
**MANDATORY**: Use type assertions for Queue constructors and Redis connections

```typescript
// ✅ CORRECT - Queue creation
let emailQueue: Queue<EmailJobData> | null = null

export function getEmailQueue(): Queue<EmailJobData> {
  if (!emailQueue) {
    emailQueue = new Queue(QUEUE_NAMES.EMAIL, {
      connection: getRedis() as any, // Type assertion for Redis connection
      ...defaultQueueOptions,
    }) as Queue<EmailJobData>
  }
  return emailQueue
}

// ✅ CORRECT - Worker creation
const emailWorker = new Worker(QUEUE_NAMES.EMAIL, processEmailJob, {
  connection: createRedisConnection() as any, // Type assertion for Redis connection
  concurrency: 5,
})
```

## Full Documentation

For complete details, examples, and additional rules, see `RULESETS.md` in the project root.

## Build Checklist

Before generating code, verify:
- [ ] All catch blocks type errors as `unknown`
- [ ] All Mongoose model calls use `(Model as any).method()` pattern
- [ ] All `request.json()` and `response.json()` have type assertions
- [ ] All Zod validations use v4-compatible syntax (`.refine()` for URLs/emails, `z.record(keyType, valueType)`)
- [ ] No JSX in `.ts` files (use `.tsx`)
- [ ] Better Auth imports use correct paths (`better-auth/client/plugins`)
- [ ] IP addresses extracted from headers, not `req.ip`
- [ ] Reduce callbacks have explicit type annotations
- [ ] Third-party clients (Stripe, Redis, etc.) use lazy initialization
- [ ] No duplicate Mongoose index definitions
- [ ] BullMQ connections use type assertions

**ALWAYS reference RULESETS.md for the complete, detailed rules before generating code.**

These examples should be used as guidance when configuring Sentry functionality within a project.

# Exception Catching

Use `Sentry.captureException(error)` to capture an exception and log the error in Sentry.
Use this in try catch blocks or areas where exceptions are expected

# Tracing Examples

Spans should be created for meaningful actions within an applications like button clicks, API calls, and function calls
Use the `Sentry.startSpan` function to create a span
Child spans can exist within a parent span

## Custom Span instrumentation in component actions

The `name` and `op` properties should be meaninful for the activities in the call.
Attach attributes based on relevant information and metrics from the request

```javascript
function TestComponent() {
  const handleTestButtonClick = () => {
    // Create a transaction/span to measure performance
    Sentry.startSpan(
      {
        op: "ui.click",
        name: "Test Button Click",
      },
      (span) => {
        const value = "some config";
        const metric = "some metric";

        // Metrics can be added to the span
        span.setAttribute("config", value);
        span.setAttribute("metric", metric);

        doSomething();
      },
    );
  };

  return (
    <button type="button" onClick={handleTestButtonClick}>
      Test Sentry
    </button>
  );
}
```

## Custom span instrumentation in API calls

The `name` and `op` properties should be meaninful for the activities in the call.
Attach attributes based on relevant information and metrics from the request

```javascript
async function fetchUserData(userId) {
  return Sentry.startSpan(
    {
      op: "http.client",
      name: `GET /api/users/${userId}`,
    },
    async () => {
      const response = await fetch(`/api/users/${userId}`);
      const data = await response.json();
      return data;
    },
  );
}
```

# Logs

Where logs are used, ensure Sentry is imported using `import * as Sentry from "@sentry/nextjs"`
Enable logging in Sentry using `Sentry.init({ enableLogs: true })`
Reference the logger using `Sentry.logger` (not destructured)
Sentry offers a consoleLoggingIntegration that can be used to log specific console error types automatically without instrumenting the individual logger calls

## Configuration

In NextJS with `@sentry/nextjs`, the standard setup uses:
- `sentry.client.config.ts` for client-side initialization
- `sentry.server.config.ts` for server-side initialization  
- `sentry.edge.config.ts` for edge runtime initialization (optional)
- `sentry.config.ts` is used by the Sentry webpack plugin for build-time configuration

Initialization does not need to be repeated in other files, it only needs to happen in the config files mentioned above. You should use `import * as Sentry from "@sentry/nextjs"` to reference Sentry functionality

### Baseline

```javascript
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  enableLogs: true,
});
```

### Logger Integration

```javascript
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  integrations: [
    // send console.log, console.warn, and console.error calls as logs to Sentry
    Sentry.consoleLoggingIntegration({ levels: ["log", "warn", "error"] }),
  ],
});
```

## Logger Examples

`Sentry.logger.fmt` is a template literal function that should be used to bring variables into the structured logs.

```javascript
import * as Sentry from "@sentry/nextjs";

// Always use Sentry.logger, not a destructured logger
Sentry.logger.trace("Starting database connection", { database: "users" });
Sentry.logger.debug(Sentry.logger.fmt`Cache miss for user: ${userId}`);
Sentry.logger.info("Updated profile", { profileId: 345 });
Sentry.logger.warn("Rate limit reached for endpoint", {
  endpoint: "/api/results/",
  isEnterprise: false,
});
Sentry.logger.error("Failed to process payment", {
  orderId: "order_123",
  amount: 99.99,
});
Sentry.logger.fatal("Database connection pool exhausted", {
  database: "users",
  activeConnections: 100,
});
```
