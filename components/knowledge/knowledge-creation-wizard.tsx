"use client"

import { useRouter } from "next/navigation"
import { useState, useCallback, useRef, useEffect } from "react"
import { Alert, AlertDescription } from "@/components/ui/alert"
import { AlertCircle } from "lucide-react"
import { MultiStepForm, type FormStep } from "@/components/ui/multi-step-form"
import { BasicInformationStep } from "@/components/knowledge/steps/basic-information-step"
import { UploadAssetsStep } from "@/components/knowledge/steps/upload-assets-step"
import { ProcessingStep } from "@/components/knowledge/steps/processing-step"
import { ReviewStep } from "@/components/knowledge/steps/review-step"
import type { FileAsset, UrlAsset, Asset } from "@/components/knowledge/knowledge-types"

interface KnowledgeCreationWizardProps {
  organizationId: string
}

interface FormData {
  basic: {
    name: string
    description: string
    sourceName: string
    websiteUrl: string
    username: string
    password: string
    loginUrl: string
    skipAuthentication: boolean
  }
  assets: {
    assets: Asset[]
    newDocUrl: string
  }
  processing: {
    knowledgeId: string | null
    jobId: string | null
    workflowId: string | null
  }
}

export function KnowledgeCreationWizard({ organizationId }: KnowledgeCreationWizardProps) {
  const router = useRouter()
  const [formData, setFormData] = useState<FormData>({
    basic: {
      name: "",
      description: "",
      sourceName: "",
      websiteUrl: "",
      username: "",
      password: "",
      loginUrl: "",
      skipAuthentication: true,
    },
    assets: {
      assets: [],
      newDocUrl: "",
    },
    processing: {
      knowledgeId: null,
      jobId: null,
      workflowId: null,
    },
  })

  const [urlError, setUrlError] = useState<string | null>(null)
  const [docUrlError, setDocUrlError] = useState<string | null>(null)
  const [videoUrlError, setVideoUrlError] = useState<string | null>(null)
  const [fileError, setFileError] = useState<string | null>(null)
  const [uploadProgress, setUploadProgress] = useState<Record<string, number>>({})
  const [uploadStatus, setUploadStatus] = useState<Record<string, "uploading" | "success" | "error">>({})
  const [error, setError] = useState<string | null>(null)
  const [isCreating, setIsCreating] = useState(false)
  const processingCompleteRef = useRef(false)
  const [currentStepIndex, setCurrentStepIndex] = useState(0)

  // Step 4 - Processing (wait for completion) - Define before useEffect that uses it
  const handleProcessingComplete = useCallback(() => {
    processingCompleteRef.current = true
    // Auto-advance to review step when processing completes
    // Small delay to ensure state updates are processed
    setTimeout(() => {
      setCurrentStepIndex((prev) => {
        if (prev === 2) { // Processing step is index 2 (0-based)
          return 3 // Review step is index 3
        }
        return prev
      })
    }, 1000) // 1 second delay to allow UI to update
  }, [])

  // Poll for completion status and auto-advance when processing completes
  useEffect(() => {
    if (currentStepIndex !== 2 || !formData.processing.knowledgeId) return // Only poll on processing step

    let lastFetchTime = 0
    const MIN_FETCH_INTERVAL = 5000 // Minimum 5 seconds between fetches

    const checkCompletion = async () => {
      const now = Date.now()
      // Throttle: only fetch if enough time has passed since last fetch
      if (now - lastFetchTime < MIN_FETCH_INTERVAL) {
        return
      }
      lastFetchTime = now

      try {
        const response = await fetch(`/api/knowledge/${formData.processing.knowledgeId}`)
        if (response.ok) {
          const result = (await response.json()) as { data?: { status?: string } }
          if (result.data?.status === "completed" && !processingCompleteRef.current) {
            processingCompleteRef.current = true
            handleProcessingComplete()
          }
        }
      } catch (err: unknown) {
        console.debug("Failed to check completion status:", err)
      }
    }

    // Check immediately
    checkCompletion()
    
    // Then poll every 5 seconds (reduced from 3 seconds)
    const interval = setInterval(checkCompletion, 5000)
    
    return () => clearInterval(interval)
  }, [currentStepIndex, formData.processing.knowledgeId, handleProcessingComplete])

  const validateUrl = (url: string): boolean => {
    if (!url.trim()) {
      return false
    }
    try {
      const urlObj = new URL(url)
      return ["http:", "https:"].includes(urlObj.protocol)
    } catch {
      return false
    }
  }

  // Handle creation from Step 3 (Upload Assets) â†’ Step 4 (Processing)
  // New two-phase architecture: Upload files first, then send ONE request with website_url + files/docs + credentials
  const handleCreateKnowledge = useCallback(async () => {
    if (isCreating) return // Prevent duplicate creation
    setIsCreating(true)
    setError(null)

    try {
      // Note: Knowledge ID will be generated by the server
      // We'll use a temporary ID for file uploads, but the server will generate the final MongoDB ObjectId
      // The server ensures all files and the final request use the same knowledge ID

      // Separate file assets and URL assets
      const fileAssets = formData.assets.assets.filter((asset): asset is FileAsset => asset.type === "file")
      const urlAssets = formData.assets.assets.filter((asset): asset is UrlAsset => asset.type !== "file")
      const docUrlAssets = urlAssets.filter((asset) => asset.type === "documentation")

      // Phase 1: Upload files to S3 (if any)
      const s3References: Array<{
        bucket: string
        key: string
        region?: string | null
        endpoint?: string | null
        presigned_url: string
        expires_at: string
      }> = []
      const fileMetadataList: Array<{
        filename: string
        size: number
        content_type: string
        uploaded_at: string
      }> = []

      if (fileAssets.length > 0) {
        // Upload all files to S3
        const fileUploadPromises = fileAssets.map(async (asset) => {
          try {
            const uploadFormData = new FormData()
            uploadFormData.append("file", asset.file)
            // Determine source_type from file extension (will be validated by backend)
            const extension = asset.file.name.toLowerCase().substring(asset.file.name.lastIndexOf("."))
            const isVideo = [".mp4", ".mov", ".avi", ".webm", ".mkv"].includes(extension)
            const isAudio = [".mp3", ".wav", ".m4a", ".ogg"].includes(extension)
            const sourceType = isVideo ? "video" : isAudio ? "audio" : "documentation"
            uploadFormData.append("source_type", sourceType)
            // Note: knowledge_id will be generated by server if not provided
            // We'll pass it in the final two-phase request

            const uploadResponse = await fetch("/api/knowledge/upload-to-s3", {
              method: "POST",
              body: uploadFormData,
            })

            if (!uploadResponse.ok) {
              const errorData = (await uploadResponse.json()) as { error?: string }
              throw new Error(`Failed to upload ${asset.file.name}: ${errorData.error || "Unknown error"}`)
            }

            const uploadResult = (await uploadResponse.json()) as {
              data?: {
                s3Reference: {
                  bucket: string
                  key: string
                  region?: string
                  endpoint?: string
                  presigned_url?: string
                  expires_at?: string
                }
                fileMetadata: {
                  filename: string
                  size: number
                  content_type: string
                  uploaded_at: string
                }
                presignedUrl?: string
                presignedUrlExpiresAt?: string
              }
            }

            const s3Ref = uploadResult.data?.s3Reference
            const fileMetadata = uploadResult.data?.fileMetadata

            if (!s3Ref || !fileMetadata) {
              throw new Error(`Invalid upload response for ${asset.file.name}`)
            }

            // Ensure presigned_url and expires_at are present
            if (!s3Ref.presigned_url) {
              if (uploadResult.data?.presignedUrl) {
                s3Ref.presigned_url = uploadResult.data.presignedUrl
                s3Ref.expires_at = uploadResult.data.presignedUrlExpiresAt || new Date(Date.now() + 3600 * 1000).toISOString()
              } else {
                throw new Error(`Missing presigned URL for ${asset.file.name}`)
              }
            }
            if (!s3Ref.expires_at) {
              s3Ref.expires_at = new Date(Date.now() + 3600 * 1000).toISOString()
            }

            return {
              s3Reference: {
                bucket: s3Ref.bucket,
                key: s3Ref.key,
                presigned_url: s3Ref.presigned_url,
                expires_at: s3Ref.expires_at,
                ...(s3Ref.region ? { region: s3Ref.region } : {}),
                ...(s3Ref.endpoint ? { endpoint: s3Ref.endpoint } : {}),
              } as {
                bucket: string
                key: string
                presigned_url: string
                expires_at: string
                region?: string
                endpoint?: string
              },
              fileMetadata: {
                filename: fileMetadata.filename,
                size: fileMetadata.size,
                content_type: fileMetadata.content_type,
                uploaded_at: fileMetadata.uploaded_at,
              },
            }
          } catch (error: unknown) {
            const errorMessage = error instanceof Error ? error.message : String(error)
            throw new Error(`Failed to upload ${asset.file.name}: ${errorMessage}`)
          }
        })

        const uploadResults = await Promise.all(fileUploadPromises)
        uploadResults.forEach((result) => {
          s3References.push(result.s3Reference)
          fileMetadataList.push(result.fileMetadata)
        })
      }

      // Collect documentation URLs (Phase 1)
      const documentationUrls: string[] = docUrlAssets.map((asset) => asset.url)

      // Prepare credentials for Phase 2 (if provided)
      const credentials =
        !formData.basic.skipAuthentication && formData.basic.username.trim() && formData.basic.password.trim()
          ? {
              username: formData.basic.username.trim(),
              password: formData.basic.password.trim(),
              ...(formData.basic.loginUrl.trim() && validateUrl(formData.basic.loginUrl.trim())
                ? { login_url: formData.basic.loginUrl.trim() }
                : {}),
            }
          : undefined

      // Send ONE two-phase request with website_url + files/docs + credentials
      const twoPhasePayload = {
        website_url: formData.basic.websiteUrl.trim(), // REQUIRED - Phase 2 target
        website_name: formData.basic.sourceName.trim() || formData.basic.websiteUrl.trim(),
        name: formData.basic.name.trim() || undefined,
        description: formData.basic.description.trim() || undefined,
        // Phase 1: Files (if any)
        ...(s3References.length > 0
          ? {
              s3_references: s3References,
              file_metadata_list: fileMetadataList,
            }
          : {}),
        // Phase 1: Documentation URLs (if any)
        ...(documentationUrls.length > 0 ? { documentation_urls: documentationUrls } : {}),
        // Phase 2: Credentials (if provided)
        ...(credentials ? { credentials } : {}),
        // Extraction options
        options: {
          max_pages: 100,
          max_depth: 10,
          extract_code_blocks: true,
          extract_thumbnails: true,
        },
        // Note: knowledge_id will be generated by server if not provided
      }

      const response = await fetch("/api/knowledge", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(twoPhasePayload),
      })

      if (!response.ok) {
        const errorData = (await response.json()) as { error?: string }
        throw new Error(errorData.error || "Failed to create knowledge")
      }

      const result = (await response.json()) as { data?: { id: string; jobId?: string | null; workflowId?: string | null } }
      const resultKnowledgeId = result.data?.id
      if (!resultKnowledgeId) {
        throw new Error("No knowledge ID returned from server")
      }

      // Update processing state
      setFormData((prev) => ({
        ...prev,
        processing: {
          knowledgeId: resultKnowledgeId,
          jobId: result.data?.jobId || null,
          workflowId: result.data?.workflowId || null,
        },
      }))
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : "Failed to create knowledge"
      setError(errorMessage)
      setIsCreating(false)
      throw err
    } finally {
      setIsCreating(false)
    }
  }, [formData, isCreating, validateUrl])

  // Step 1 Validation
  const validateStep1 = useCallback((): boolean => {
    if (!validateUrl(formData.basic.websiteUrl)) {
      setUrlError("Please enter a valid website URL (e.g., https://example.com)")
      return false
    }
    setUrlError(null)
    return true
  }, [formData.basic.websiteUrl])


  // Step 3 - Trigger creation when leaving this step
  const validateStep3 = useCallback(async (): Promise<boolean> => {
    // Trigger knowledge creation when moving to processing step
    if (!formData.processing.knowledgeId && !isCreating) {
      try {
        await handleCreateKnowledge()
        // Creation started - processing step will show progress
        return true // Allow move to processing step
      } catch {
        // Error handled in handleCreateKnowledge
        return false // Don't advance on error
      }
    }
    return true
  }, [formData.processing.knowledgeId, isCreating, handleCreateKnowledge])


  // Step 5 - Review (no validation)
  const validateStep5 = useCallback((): boolean => {
    return true
  }, [])

  // Handle form completion (from Review step)
  const handleComplete = useCallback(async () => {
    // This is called when Review step completes
    // Navigate to knowledge detail page
    if (formData.processing.knowledgeId) {
      router.push(`/knowledge/${formData.processing.knowledgeId}`)
    }
  }, [router, formData.processing.knowledgeId])

  // Memoized update handlers to prevent infinite loops
  const handleBasicUpdate = useCallback((data: FormData["basic"]) => {
    setFormData((prev) => ({ ...prev, basic: data }))
  }, [])


  const handleAssetsUpdate = useCallback((data: FormData["assets"]) => {
    setFormData((prev) => ({ ...prev, assets: data }))
  }, [])

  // Define steps
  const steps: FormStep[] = [
    {
      id: "basic",
      title: "Basic Information",
      description: "Name, description, and website URL",
      component: (
        <BasicInformationStep
          name={formData.basic.name}
          description={formData.basic.description}
          sourceName={formData.basic.sourceName}
          websiteUrl={formData.basic.websiteUrl}
          username={formData.basic.username}
          password={formData.basic.password}
          loginUrl={formData.basic.loginUrl}
          skipAuthentication={formData.basic.skipAuthentication}
          onUpdate={handleBasicUpdate}
          urlError={urlError}
          onUrlError={setUrlError}
        />
      ),
      validation: validateStep1,
    },
    {
      id: "assets",
      title: "Upload Assets",
      description: "Files and documentation URLs",
      component: (
        <UploadAssetsStep
          assets={formData.assets.assets}
          newDocUrl={formData.assets.newDocUrl}
          docUrlError={docUrlError}
          fileError={fileError}
          uploadProgress={uploadProgress}
          uploadStatus={uploadStatus}
          onUpdate={handleAssetsUpdate}
          onErrors={(errors) => {
            setDocUrlError(errors.docUrlError)
            setFileError(errors.fileError)
          }}
        />
      ),
      validation: validateStep3,
      nextButtonLabel: () => formData.assets.assets.length > 0 ? "Next" : "Skip",
    },
    {
      id: "processing",
      title: "Processing",
      description: "Knowledge extraction in progress",
      component: (
        <ProcessingStep
          knowledgeId={formData.processing.knowledgeId}
          jobId={formData.processing.jobId}
          workflowId={formData.processing.workflowId}
          onComplete={() => {
            processingCompleteRef.current = true
            handleProcessingComplete()
          }}
        />
      ),
      validation: async () => {
        // Trigger creation if not started yet
        if (!formData.processing.knowledgeId && !isCreating) {
          try {
            await handleCreateKnowledge()
            // After creation starts, wait for completion via onComplete callback
            // Don't advance immediately - KnowledgeProgress will call onComplete when done
            return false
          } catch {
            // Error handled in handleCreateKnowledge, don't advance
            return false
          }
        }
        // If creation started, wait for completion
        if (formData.processing.knowledgeId && !processingCompleteRef.current) {
          return false // Still processing
        }
        // Processing completed - allow advance
        return processingCompleteRef.current
      },
    },
    {
      id: "review",
      title: "Review",
      description: "Review and finalize",
      component: (
        <ReviewStep
          name={formData.basic.name}
          description={formData.basic.description}
          sourceName={formData.basic.sourceName}
          websiteUrl={formData.basic.websiteUrl}
          assetsCount={formData.assets.assets.length}
          knowledgeId={formData.processing.knowledgeId}
          onView={() => {
            if (formData.processing.knowledgeId) {
              router.push(`/knowledge/${formData.processing.knowledgeId}`)
            }
          }}
        />
      ),
      validation: validateStep5,
    },
  ]

  return (
    <div className="space-y-6">
      {error && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription className="text-sm">{error}</AlertDescription>
        </Alert>
      )}
      <div className="space-y-6">
        <MultiStepForm
          steps={steps}
          onComplete={handleComplete}
          onCancel={() => router.push("/knowledge")}
          currentStepIndex={currentStepIndex}
          onStepChange={setCurrentStepIndex}
        />
      </div>
    </div>
  )
}
