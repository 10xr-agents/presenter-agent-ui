import mongoose, { Schema } from "mongoose"

/**
 * Message Model (Task 3)
 *
 * Stores individual messages in a conversation thread. Represents both user instructions and assistant responses.
 * Enables the backend to own conversation history, preventing client-side manipulation.
 *
 * - Created for each user query and assistant response
 * - Links to parent Session via sessionId
 * - Sequence numbers maintain message order
 * - All accesses scoped by tenantId
 *
 * Tenant ID: userId (normal mode) or organizationId (organization mode)
 */

export type MessageRole = "user" | "assistant" | "system"
export type MessageStatus = "success" | "failure" | "pending"

export interface IMessage extends mongoose.Document {
  messageId: string // UUID (generated by server, not _id)
  sessionId: string // Links to parent Session
  userId: string // User who owns the message (for security)
  tenantId: string // userId or organizationId
  role: MessageRole // Message role
  content: string // The main text/thought (user instruction or assistant thought)
  actionPayload?: {
    // Structured action data (e.g., { type: 'click', target: 123, elementId: 123 })
    [key: string]: unknown
  }
  actionString?: string // Action string (e.g., "click(123)")
  status?: MessageStatus // Action execution status
  error?: {
    // Error details if action failed
    message?: string
    code?: string
    [key: string]: unknown
  }
  sequenceNumber: number // Message order within session (0-indexed)
  timestamp: Date // When message was created
  // Improvement 3: DOM snapshot reference (instead of embedding)
  snapshotId?: string // Reference to Snapshot collection (if DOM snapshot needed)
  domSummary?: string // Small text summary of DOM state for context (e.g., "Login page with User/Pass fields")
  metadata?: {
    // Debug info: tokens_used, latency, llm_model, verification_result, etc.
    tokens_used?: {
      promptTokens?: number
      completionTokens?: number
    }
    latency?: number
    llm_model?: string
    verification_result?: {
      success?: boolean
      confidence?: number
      reason?: string
    }
    [key: string]: unknown
  }
}

const MessageSchema = new Schema<IMessage>(
  {
    messageId: {
      type: String,
      required: true,
      unique: true,
    },
    sessionId: {
      type: String,
      required: true,
      index: true,
    },
    userId: {
      type: String,
      required: true,
      index: true,
    },
    tenantId: {
      type: String,
      required: true,
      index: true,
    },
    role: {
      type: String,
      enum: ["user", "assistant", "system"],
      required: true,
    },
    content: {
      type: String,
      required: true,
    },
    actionPayload: {
      type: Schema.Types.Mixed,
      required: false,
    },
    actionString: {
      type: String,
      required: false,
    },
    status: {
      type: String,
      enum: ["success", "failure", "pending"],
      required: false,
    },
    error: {
      type: Schema.Types.Mixed,
      required: false,
    },
    sequenceNumber: {
      type: Number,
      required: true,
      index: true,
    },
    timestamp: {
      type: Date,
      required: true,
      default: Date.now,
      index: true,
    },
    // Improvement 3: DOM snapshot reference
    snapshotId: {
      type: String,
      required: false,
      index: true,
    },
    domSummary: {
      type: String,
      required: false,
    },
    metadata: {
      type: Schema.Types.Mixed,
      required: false,
    },
  },
  {
    timestamps: true,
  }
)

// Indexes for efficient queries
// Note: messageId already has unique: true which creates an index automatically
MessageSchema.index({ sessionId: 1, sequenceNumber: 1 })
MessageSchema.index({ userId: 1, timestamp: -1 })
MessageSchema.index({ tenantId: 1, sessionId: 1, sequenceNumber: 1 })

export const Message =
  mongoose.models.Message || mongoose.model<IMessage>("Message", MessageSchema)
