# Thin Client Implementation: Server-Side Roadmap

**Document Version:** 1.9  
**Last Updated:** January 26, 2026 — Task 4 **complete**: `GET/POST /api/v1/user/preferences` implemented (§5); UserPreference model, Zod schemas, CORS verified  
**Date:** January 26, 2026  
**Status:** Execution-Ready (Backend)  
**Source:** `SERVER_SIDE_AGENT_ARCH.md` (auth, interact, resolve, RAG, history)

**Sync:** This document is the **implementation roadmap**. The **specification** is `SERVER_SIDE_AGENT_ARCH.md`. Keep both in sync; on conflict, prefer ROADMAP + enriched thread (Better Auth adapters, MongoDB/Mongoose, resolve = internal/debugging).

**Counterpart:** Client-side work is in `THIN_CLIENT_ROADMAP_CLIENT.md`. Tasks 1–3 are **sequential**; server and client work for a given task ship together for end-to-end verification.

---

## 1. Overview

This document is the **server-side** implementation roadmap for the Thin Client architecture. Each task covers **persistence (Mongoose schemas where needed)** and **API endpoint development** only. We use **MongoDB** with **Prisma (Better Auth)** and **Mongoose (app)**; there are **no SQL migrations**. Extension (client) integration for the same features is described in `THIN_CLIENT_ROADMAP_CLIENT.md`.

### 1.1 Principles

- **Vertical slices:** Each task delivers the backend (DB + API) for one feature. No standalone “schema-only” or “API scaffolding–only” phases.
- **Strict sequencing:** Task 2 depends on Task 1 (auth, tenant, allowlist). Task 3 depends on Task 1 and Task 2 (RAG, domain checks).
- **Tenant + domain isolation:** All DB and RAG access scoped by **Tenant ID** (from session) and **Active Domain** (from request URL) when org-specific. **`allowed_domains`** is a **filter** (§1.6): it decides when to use org-specific RAG, not when to block access. We help on **all** domains; public-only when no org knowledge.

### 1.2 Prerequisites

- Next.js application (App Router) with deployment target (e.g. Vercel, Node server).
- **MongoDB** (Atlas recommended). **No PostgreSQL, no Drizzle.** See §1.4 for DB stack.
- CORS configured to allow extension origin (`chrome-extension://<id>`) for `/api/auth/*`, `/api/v1/*`, `/api/agent/*`, `/api/knowledge/*`.
- At least one **tenant** (user or organization) and one **invited user** (admin/seed) for testing. Tenant has `allowed_domains` (e.g. `*.example.com`).

### 1.3 Client Context: Chrome Extension (Non-Server)

Auth APIs are consumed by a **Chrome extension** that runs in the browser (not on a server). Implications:

- **Origin:** Extension uses `chrome-extension://<extension-id>`. All API calls to the Next.js backend are **cross-origin**.
- **No cookies:** Use **Bearer tokens** only. Extension stores `accessToken` in `chrome.storage.local`, sends `Authorization: Bearer <accessToken>`, and uses `credentials: "omit"` on `fetch`. Cookie-based sessions are not used for the extension.
- **CORS:** Backend must allow extension origin for `/api/auth/*`, `/api/v1/*`, `/api/agent/*`, `/api/knowledge/*` (including preflight `OPTIONS`). **Infer Next.js** for configuring CORS (middleware, `next.config`, or route-level headers).
- **Trusted origins:** Better Auth must treat the extension as a trusted origin. **Infer Better Auth** — configure `trustedOrigins` with `chrome-extension://<id>` (or `chrome-extension://*` for dev only).
- **Sign-up vs login:** Sign-up is **invite-based** and lives **outside** the extension (web app only). The extension supports **login** only (email/password; optional social, e.g. Google).

### 1.4 Database Stack (MongoDB, Prisma, Mongoose)

This project uses **MongoDB** only. There are **no SQL migrations** (no PostgreSQL-style migration files).

- **Prisma (Better Auth)** — `prisma/schema.prisma`, generated by Better Auth CLI. Used **only** for auth: `User`, `Session`, `Account`, `Organization`, `Member`, `Invitation`, `Verification`. We **reuse** these; we **do not** add new auth tables or run auth migrations.
- **Mongoose (Application data)** — `lib/db/mongoose.ts`, `lib/models/*`. Used for knowledge, screen agents, teams, billing, etc. New app data (e.g. `allowed_domains`, `tasks`, `task_actions`) is added as **Mongoose schemas** in `lib/models/`, not as Prisma models or SQL migrations.

**Tenant:** In normal mode, tenant = **user** (`userId`). In organization mode, tenant = **organization** (`organizationId`). No separate `tenants` table. See `getTenantState` / `getActiveOrganizationId` and ARCHITECTURE.md.

**Implications for this roadmap:**
- **No new auth schemas** — User, Session, Organization come from Better Auth (Prisma). Do not create additional user/session/tenant tables.
- **New app schemas** — Add **Mongoose** models only (e.g. `allowed_domains` for allowlist, `tasks` / `task_actions` for Task 3). No Prisma schema changes for auth.

### 1.5 Interact vs Resolve (Knowledge Use)

| Endpoint | Who uses the knowledge? | What the extension gets | Use case |
|----------|--------------------------|--------------------------|----------|
| **`POST /api/agent/interact`** | LLM (inside backend) | `thought`, `action` — **no** chunks/citations | Task execution: RAG grounds the LLM; user sees only **results** (actions, thought). |
| **`GET /api/knowledge/resolve`** | Internal / debugging | `context`, `citations` — raw chunks | **Internal use and debugging only.** Inspect what RAG returns for a URL/query; **not** for extension overlay or end-user display. |

- **Interact:** Extension sends `url`, `query`, `dom`, `taskId?`. Backend runs RAG, injects knowledge **into the LLM prompt**, calls LLM, returns **`NextActionResponse`**. The extension **never** receives raw chunks or citations — only the next action to execute.
- **Resolve:** Same RAG + tenant/domain checks, **no LLM**. Returns **`ResolveKnowledgeResponse`** (`context`, `citations`). Used for **internal tooling and debugging** (e.g. “what knowledge do we have for this page?”). The extension does **not** use resolve for overlay/tooltips; task execution uses **interact** only. See `SERVER_SIDE_AGENT_ARCH.md` §5.6.

### 1.6 Knowledge Types & `allowed_domains` as Filter (Not Assert)

We support **two types of knowledge**:

| Type | Description | When used |
|------|-------------|-----------|
| **Public knowledge** | Publicly available information (e.g. general web, common docs). | **Always.** We help on **all** domains. |
| **Organization-specific knowledge** | Knowledge ingested and stored per tenant (DB), scoped by domain. | **Only** when the **Active Domain** matches `allowed_domains` and we have org-specific data for that domain. |

**`allowed_domains` is a filter, not an assert.** It decides **when to query org-specific RAG**, not whether to block access.

- **On a domain with org-specific knowledge** (domain matches `allowed_domains` and we have chunks for that domain): we query RAG (org + public), ground results in that knowledge, and return as usual. No special UI.
- **On other domains**: we **do not** query org-specific RAG. We still return suggestions using **public knowledge only**. We **never** 403. The API indicates absence of org-specific knowledge (e.g. `hasOrgKnowledge: false`) so the **extension** can show a dialog: *“There isn’t any knowledge present for this website — all our suggestions are based on publicly available information.”*

**Summary:** We always help (suggestions on all domains). `allowed_domains` filters *when* we add the org-specific knowledge layer; it does **not** restrict which domains the user can use the extension on.

---

## 2. Task 1: Authentication & API Client (Server)

**Objective:** Auth endpoints and shared session resolution. Users log in (invite-based); backend issues a Bearer token. All protected routes validate the token and resolve `userId`, `tenantId`.

**Deliverable:** Login, session, and logout work; `getSessionFromToken` is used by all protected routes. Client integration is in `THIN_CLIENT_ROADMAP_CLIENT.md` §2.

---

### 2.1 Persistence for Task 1 (No New Auth Schemas)

We **reuse** Better Auth (Prisma) for users, sessions, and organizations. **No new auth tables or schemas.** We add **one** new Mongoose model for the domain **filter** (§1.6).

#### 2.1.1 Reuse (no changes)

- **Users, sessions, accounts** — Better Auth’s `User`, `Session`, `Account` (Prisma). Credential check, token issuance, and session invalidation use these. Bearer plugin uses the same sessions.
- **Tenant** — Derived from **user** (normal mode) or **organization** (org mode). No `tenants` table. Use `getTenantState` / `getActiveOrganizationId` and existing org membership.

#### 2.1.2 New Mongoose model: `allowed_domains`

- **Collection:** `allowed_domains` (or equivalent). **Mongoose** schema in `lib/models/`.
- **Fields:** e.g. `tenantId` (string; `userId` or `organizationId`), `domainPattern` (string; e.g. `*.example.com`), `createdAt`.
- **Purpose:** **Filter** (not assert) for when to use **org-specific** RAG (§1.6). Tasks 2–3 load allowed domains for the tenant and check `Active Domain` against these patterns. If the domain matches → query org-specific RAG. If not → use **public knowledge only**; we still return 200 and suggestions. We **do not** 403 based on `allowed_domains`.

**No migrations:** Add the Mongoose schema only. Optionally seed one tenant with `allowed_domains` for QA.

---

### 2.2 API Endpoints (Task 1)

- **`POST /api/v1/auth/login`**  
  - Body: `{ email, password }`.  
  - Validate credentials against `users`; check user and tenant `status`.  
  - Issue access token (JWT or opaque), optionally store in `sessions`.  
  - Response: `{ accessToken, expiresAt, user: { id, email, name }, tenantId, tenantName }`.

- **`GET /api/v1/auth/session`**  
  - Auth: Bearer token.  
  - Resolve `userId`, `tenantId` from token; return `{ user, tenantId, tenantName }`.  
  - 401 if invalid or expired.

- **`POST /api/v1/auth/logout`**  
  - Auth: Bearer token.  
  - Invalidate token (e.g. delete from `sessions` or blacklist).  
  - Response: 204 No Content.

**Shared auth helper:** `getSessionFromToken(Authorization header) → { userId, tenantId } | null`. Use in all protected routes.

---

### 2.3 Definition of Done / QA Verification (Task 1 — Server)

- [x] Better Auth (Prisma) reused for users/sessions; **no** new auth schemas. `allowed_domains` Mongoose model exists (**filter** §1.6, not assert) and optionally seeded for one tenant.
- [x] `POST /api/v1/auth/login` returns 200 and `accessToken` for valid invited user; 401 for invalid credentials. **Implemented:** `/app/api/v1/auth/login/route.ts` — wraps Better Auth sign-in, extracts `set-auth-token` header, returns contract response with CORS.
- [x] `GET /api/v1/auth/session` returns 200 with user/tenant when Bearer valid; 401 when missing or invalid. **Implemented:** `/app/api/v1/auth/session/route.ts` — uses `getSessionFromToken`, returns user/tenant with CORS.
- [x] `POST /api/v1/auth/logout` invalidates token; subsequent session check returns 401. **Implemented:** `/app/api/v1/auth/logout/route.ts` — calls Better Auth signOut, returns 204 with CORS.
- [ ] End-to-end: extension can log in, session check, logout (see client roadmap). QA verifies on **live site**. **Pending:** Client-side implementation in `THIN_CLIENT_ROADMAP_CLIENT.md`.

**Implementation Status:**
- ✅ Better Auth: Bearer plugin + `trustedOrigins` added to `lib/auth/auth.ts`
  - Bearer plugin imported from `better-auth/plugins`
  - `trustedOrigins`: Production uses `chrome-extension://${CHROME_EXTENSION_ID}`, dev uses `chrome-extension://*` (wildcard for development)
  - **Note:** In production, set `CHROME_EXTENSION_ID` env var. Dev wildcard may need specific extension IDs added manually if issues occur.
- ✅ Mongoose model: `AllowedDomain` created in `lib/models/allowed-domain.ts`
  - **Purpose:** **Filter** (§1.6) for when to use org-specific RAG; **not** used to 403. Tasks 2–3 use it to decide org vs public-only.
  - Fields: `tenantId` (string, indexed), `domainPattern` (string), `createdAt` (timestamp)
  - Unique index on `{ tenantId, domainPattern }`
- ✅ Auth helper: `getSessionFromToken` / `getSessionFromRequest` in `lib/auth/session.ts`
  - Validates Bearer token via `auth.api.getSession({ headers })`
  - Resolves tenant (user or organization mode)
  - Returns `{ userId, tenantId }` or `null`
- ✅ API routes: `/api/v1/auth/login`, `/api/v1/auth/session`, `/api/v1/auth/logout` with CORS
  - **Login** (`POST /api/v1/auth/login`): Uses `auth.api.signInEmail({ body, headers, returnHeaders: true })` per Better Auth server-side API. Extracts `set-auth-token` header, returns contract response.
  - **Session** (`GET /api/v1/auth/session`): Uses `auth.api.getSession({ headers })` with Authorization header. Returns user/tenant info.
  - **Logout** (`POST /api/v1/auth/logout`): Uses `auth.api.signOut({ headers })` with Authorization header. Returns 204.
  - All routes handle CORS preflight (OPTIONS) and add CORS headers to responses.
- ✅ CORS helper: `lib/utils/cors.ts` for extension origin handling
  - `getCorsHeaders(origin)`: Returns CORS headers for chrome-extension origins
  - `handleCorsPreflight(req)`: Handles OPTIONS requests
  - `addCorsHeaders(req, response)`: Adds CORS headers to responses

**Implementation Verification (per Better Auth & Next.js docs):**
- ✅ **Better Auth API usage**: Using `auth.api.signInEmail` with `returnHeaders: true` (server-side pattern per Better Auth docs)
- ✅ **Bearer plugin**: Correctly imported and configured in auth config
- ✅ **Session handling**: Using `auth.api.getSession({ headers })` with Authorization header (Bearer plugin pattern)
- ✅ **Next.js route handlers**: Using `NextRequest`/`NextResponse`, proper async handlers, OPTIONS for CORS
- ✅ **Error handling**: All routes catch errors, return appropriate status codes, include CORS headers on errors
- ✅ **Type safety**: Using type assertions for `request.json()`, proper Zod validation

**Exit criterion:** Server-side Task 1 complete when all above are verified. Proceed to Task 2 only after sign-off.

**Implementation Verification Summary (January 25, 2026):**

✅ **Better Auth Integration:**
- Bearer plugin correctly imported from `better-auth/plugins` and added to plugins array
- `trustedOrigins` configured for chrome-extension origins (prod: specific ID, dev: wildcard)
- Using `auth.api.signInEmail({ returnHeaders: true })` per Better Auth server-side API documentation
- Using `auth.api.getSession({ headers })` with Authorization header for Bearer token validation
- Using `auth.api.signOut({ headers })` with Authorization header for session invalidation

✅ **Next.js Integration:**
- Route handlers use `NextRequest`/`NextResponse` correctly
- OPTIONS handlers implemented for CORS preflight
- Proper async/await error handling
- Type-safe request body parsing with Zod validation
- CORS headers added to all responses (success and error)

✅ **Code Quality:**
- No linter errors
- Proper error handling with Sentry integration
- Type assertions for JSON parsing per RULESETS.md
- Mongoose model follows existing patterns
- Helper functions properly documented

✅ **Contract Compliance:**
- Login returns `{ accessToken, expiresAt, user, tenantId, tenantName }` per §2.2
- Session returns `{ user, tenantId, tenantName }` per §2.2
- Logout returns 204 No Content per §2.2
- All routes handle CORS for extension origin

**Pending:** End-to-end testing with Chrome extension (requires client-side implementation).

---

### 2.4 Auth Implementation: Better Auth & Next.js

Use this section to implement Task 1 auth **correctly** with the existing stack. It specifies **where to infer Better Auth** vs **where to infer Next.js**, and how they fit together.

#### 2.4.1 Where to Infer **Better Auth**

| Concern | Infer | Notes |
|--------|-------|--------|
| **Auth runtime** | Better Auth | `lib/auth/auth.ts` — existing Better Auth config. Reuse credential validation, user/tenant resolution, session storage. |
| **Bearer plugin** | Better Auth | Add `bearer()` to `plugins`. Enables token-based auth (no cookies). Token issued on sign-in via **`set-auth-token`** response header. Use for extension clients. See [Bearer Token Authentication](https://beta.better-auth.com/docs/plugins/bearer). |
| **Trusted origins** | Better Auth | In auth config: `trustedOrigins: ["chrome-extension://<id>"]` (prod). Dev: `chrome-extension://*` allowed but less secure. Required so Better Auth accepts requests from the extension. See [Browser Extension Guide](https://www.better-auth.com/docs/guides/browser-extension-guide). |
| **Session from token** | Better Auth | `auth.api.getSession({ headers })` works when `Authorization: Bearer <token>` is present. Use this inside `getSessionFromToken`: validate Bearer header → pass headers to `getSession` → map result to `{ userId, tenantId }` or `null`. |
| **Sign-in / sign-out** | Better Auth | Credential check, session create/invalidate. Sign-up stays on web (invite-based). Extension only **login**. |
| **Handler mount** | Better Auth | `toNextJsHandler(auth)` from `better-auth/next-js` at `app/api/auth/[...all]/route.ts`. Keep as-is; do **not** replace with custom auth routes. |

**References:** [Better Auth – Browser Extension Guide](https://www.better-auth.com/docs/guides/browser-extension-guide), [Bearer Plugin](https://beta.better-auth.com/docs/plugins/bearer), [Options / trustedOrigins](https://www.better-auth.com/docs/reference/options).

#### 2.4.2 Where to Infer **Next.js**

| Concern | Infer | Notes |
|--------|-------|--------|
| **API routes** | Next.js | App Router routes under `app/api/`. **New:** `app/api/v1/auth/login/route.ts`, `app/api/v1/auth/session/route.ts`, `app/api/v1/auth/logout/route.ts` implementing the **contract** in §2.2. These **wrap** Better Auth (e.g. call sign-in, read `set-auth-token`, return `{ accessToken, expiresAt, user, tenantId, tenantName }`). |
| **CORS** | Next.js | Allow `chrome-extension://<id>` for `/api/auth/*`, `/api/v1/*`, `/api/agent/*`, `/api/knowledge/*`. Handle `OPTIONS` preflight. Use middleware, `next.config` headers, or route-level `Response` headers. See [Next.js middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware) and API route CORS patterns. |
| **Request/response** | Next.js | `NextRequest` / `NextResponse` in route handlers. Parse `Authorization` header, forward to Better Auth or `getSessionFromToken`, return JSON or 204 per §2.2. |

**References:** [Next.js App Router](https://nextjs.org/docs/app), [Next.js Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware), [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers).

#### 2.4.3 Implementation Flow (Task 1) — ✅ COMPLETED

1. **Better Auth:** ✅ Added `bearer()` plugin and `trustedOrigins` (extension origin). `toNextJsHandler(auth)` remains at `/api/auth/[...all]`.
   - Bearer plugin: `import { bearer } from "better-auth/plugins"` → `plugins: [bearer(), organization(...)]`
   - Trusted origins: Production uses specific extension ID, dev uses wildcard pattern
2. **Adapter routes:** ✅ Implemented `POST /api/v1/auth/login`, `GET /api/v1/auth/session`, `POST /api/v1/auth/logout` per §2.2.  
   - **Login:** Uses `auth.api.signInEmail({ body, headers, returnHeaders: true })` per Better Auth server-side API. Extracts `set-auth-token` from response headers; returns `{ accessToken, expiresAt, user, tenantId, tenantName }` in JSON with CORS headers.  
   - **Session:** Extracts Bearer token from `Authorization` header; calls `auth.api.getSession({ headers })` with Authorization header; returns `{ user, tenantId, tenantName }` or 401 with CORS headers.  
   - **Logout:** Validates Bearer via `auth.api.getSession`, then calls `auth.api.signOut({ headers })` with Authorization header; returns 204 with CORS headers.
3. **`getSessionFromToken`:** ✅ Helper implemented in `lib/auth/session.ts`. Input: `Authorization` header. Output: `{ userId, tenantId } | null`. Uses `auth.api.getSession({ headers })` when Bearer is present. Also provides `getSessionFromRequest(requestHeaders)` convenience wrapper.
4. **CORS (Next.js):** ✅ Implemented in `lib/utils/cors.ts`. All `/api/v1/auth/*` routes handle OPTIONS preflight and add CORS headers. Extension origin (`chrome-extension://*`) is allowed.

#### 2.4.4 Token Handling vs Doc Contract — ✅ IMPLEMENTED

- **Thin Client contract (§2.2):** Login returns `{ accessToken, expiresAt, user, tenantId, tenantName }` in the **response body**.
- **Bearer plugin:** Token is provided in the **`set-auth-token`** response **header** on sign-in.
- **Resolution:** ✅ The **`/api/v1/auth/login`** adapter uses `auth.api.signInEmail({ returnHeaders: true })` per Better Auth server-side API, reads `set-auth-token` from response headers, and **also** returns `accessToken` (and related fields) in the JSON body so the extension can store it in `chrome.storage.local` and send `Authorization: Bearer <accessToken>` on subsequent requests. Session and logout adapters consume the same Bearer token via `auth.api.getSession({ headers })` and `auth.api.signOut({ headers })`.

**Implementation Details:**
- Login route uses `auth.api.signInEmail` with `returnHeaders: true` to get the `set-auth-token` header
- Session route uses `auth.api.getSession({ headers })` with Authorization header from request
- Logout route validates session first, then calls `auth.api.signOut({ headers })` with Authorization header
- All routes properly handle errors and include CORS headers

---

## 3. Task 2: Runtime Knowledge Resolution (Server)

**Objective:** Resolve endpoint that **proxies** to the **browser automation / knowledge extraction service**. Backend validates tenant; uses **`allowed_domains` as filter** (§1.6) to decide when to call the extraction service (org-specific) vs public-only. Returns **`ResolveKnowledgeResponse`** with `hasOrgKnowledge`. **Internal use and debugging only** — not for extension overlay or end-user display (see §1.5). **No duplicate storage or RAG** in the Next.js app (§3.1).

**Deliverable:** `GET /api/knowledge/resolve` returns **200** for any valid `url` when Bearer valid. **Org-specific:** proxy to extraction service’s resolve/query endpoint; return chunks/citations. **Public-only:** no extraction call; return `hasOrgKnowledge: false`, `context: []`, `citations: []`. **No** 403 based on domain. Response includes `hasOrgKnowledge` so extension can show “no knowledge for this website” dialog when applicable.

---

### 3.1 Persistence for Task 2 (Proxy to Extraction Service)

**No duplicate storage or RAG in the Next.js app.** We **proxy** resolve to the **browser automation / knowledge extraction service**. Writing chunks or RAG logic again here would duplicate work and add complexity.

- **Reuse:** `allowed_domains` (Task 1), tenant resolution (user / organization). Optionally **`KnowledgeSource`** (and related models) only to **map** `(tenantId, domain)` → `knowledge_id`(s) when the extraction service is queried by `knowledge_id` (e.g. existing `GET /api/knowledge/query/{knowledge_id}`).
- **Chunks / RAG:** Live in the **extraction service**. Next.js does **not** add Mongoose schemas for chunks or documents. We **call the extraction service’s endpoint** (resolve-by-url, or query-by-knowledge_id after lookup) and normalize the response to **`ResolveKnowledgeResponse`**.
- **Extraction service:** Must expose a **resolve** endpoint that we proxy to. **Detailed request/response schema** → **`BROWSER_AUTOMATION_RESOLVE_SCHEMA.md`**. Summary: `GET /api/knowledge/resolve?url=...&query=...` with `X-Tenant-ID` header; returns `{ context: KnowledgeChunk[], citations?: Citation[] }`. Alternative: use existing `GET /api/knowledge/query/{knowledge_id}` plus our lookup of `knowledge_id`(s) from `KnowledgeSource` by `(tenantId, domain)`; in that case, normalize their response to the resolve contract.

**Seeding (optional):** Seed one tenant with `allowed_domains` and ensure at least one `KnowledgeSource` (or extraction job) exists whose domain matches an allowed pattern, so resolve can return non-empty context for QA.

---

### 3.2 API Endpoint (Task 2)

- **`GET /api/knowledge/resolve`** — **Internal use and debugging only** (§1.5). Not for extension overlay.  
  - Query params: `url` (required), `query` (optional).  
  - Auth: Bearer. Resolve `userId`, `tenantId` via `getSessionFromToken`.  
  - **Active Domain:** `domain = new URL(url).hostname`.  
  - **`allowed_domains` as filter (§1.6):** Load `allowed_domains` for `tenant_id`. If `domain` matches a pattern **and** we have org-specific knowledge for that domain → `hasOrgKnowledge = true`; **proxy** to extraction service. Otherwise → `hasOrgKnowledge = false`; **public knowledge only** (no extraction service call); **never** 403.  
  - **Org-specific path:** **Proxy** to the extraction service’s resolve endpoint. **Schema:** `BROWSER_AUTOMATION_RESOLVE_SCHEMA.md`. Pass `url`, `query`, and `X-Tenant-ID: tenant_id`. Normalize the extraction service response to **`ResolveKnowledgeResponse`** (`context`, `citations`).  
  - **Public-only path:** Return `hasOrgKnowledge: false`, `context: []`, `citations: []` (no call to extraction service).  
  - Response: **`ResolveKnowledgeResponse`** — `{ allowed: true, domain, hasOrgKnowledge: boolean, context: KnowledgeChunk[], citations?: Citation[] }`.  
    - `hasOrgKnowledge`: `true` when we proxied to extraction service and used org-specific knowledge; `false` otherwise. Extension can use this to show a dialog (e.g. “No knowledge for this website — suggestions are from publicly available information only”).  
  - If no chunks from extraction service, return `context: []`, `citations: []`, `hasOrgKnowledge` as above.

**Isolation:** Always pass `tenant_id` when calling the extraction service. Use **Active Domain** only for **filtering** (when to use org RAG), not for blocking access.

---

### 3.3 Definition of Done / QA Verification (Task 2 — Server)

- [x] **No** new Mongoose models for chunks/documents. Resolve **proxies** to extraction service (§3.1). Reuse `allowed_domains`, tenant resolution, and optionally `KnowledgeSource` for `(tenantId, domain)` → `knowledge_id` lookup only.
- [x] `GET /api/knowledge/resolve` returns **200** for any valid `url` when Bearer valid; **401** without token. **No** 403 based on `allowed_domains` (§1.6).
- [x] Response includes `hasOrgKnowledge`: `true` when we proxied to extraction service and used org-specific knowledge; `false` when public-only (no extraction call). Enables extension to show “no knowledge for this website” dialog when `hasOrgKnowledge === false`.
- [x] Org-specific path: **proxy** to extraction service with `tenant_id` (and `url`/`query`). Public-only path: no extraction call. No cross-tenant/cross-domain leakage.
- [x] Resolve usable for **internal use and debugging** (e.g. tooling, dashboards). **Not** for extension overlay; extension uses **interact** only for task execution (§1.5).

**Exit criterion:** Server-side Task 2 complete when all above are verified. Proceed to Task 3 only after sign-off.

---

### 3.4 Verification vs MongoDB & Next.js

**Task 2 status:** **Complete.** `GET /api/knowledge/resolve` is implemented at `app/api/knowledge/resolve/route.ts`. OPTIONS (CORS preflight) + GET (auth, `allowed_domains` filter, proxy vs public-only, `ResolveKnowledgeResponse` with CORS). Uses resolve-client, `allowed_domains`, domain-match, session, CORS; extraction service contract → `BROWSER_AUTOMATION_RESOLVE_SCHEMA.md`.

**MongoDB** ([production checklist](https://www.mongodb.com/docs/manual/administration/production-checklist-development/), [schema design](https://www.mongodb.com/docs/manual/administration/production-checklist-development/#schema-design)):

| Check | Status | Notes |
|-------|--------|-------|
| Collections & indexes explicit | ✅ | `allowed_domains`: compound `Schema.index({ tenantId, domainPattern }, { unique: true })` only; no `index: true` (RULESETS §15). |
| No unbounded indexed arrays | ✅ | `allowed_domains` has no indexed arrays. |
| Document size & schema | ✅ | Small docs; well under 16MB. |
| Connection pattern | ✅ | Mongoose singleton (`connectDB`) avoids connection growth in serverless; driver uses pooling. |
| Retries / backoff / maxTimeMS | ⚠️ | Not in `connectDB` or resolve-client. Add app-level retries for extraction-service calls and DB if needed (MongoDB: “handle transient errors, exponential backoff”). |

**Next.js** ([Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), [production checklist](https://nextjs.org/docs/app/guides/production-checklist)):

| Check | Status | Notes |
|-------|--------|-------|
| API via Route Handlers | ✅ | Resolve uses Route Handlers (OPTIONS + GET); same pattern as auth adapters. |
| Error handling | ✅ | Try/catch, typed `unknown`, `errorResponse`, CORS on all responses. |
| Env vars | ✅ | `KNOWLEDGE_EXTRACTION_API_URL` / `NEXT_PUBLIC_KNOWLEDGE_EXTRACTION_API_URL`; `.env` in `.gitignore`. |

---

## 4. Task 3: Server-Side Action Loop (Server)

**Objective:** Action loop endpoint. Backend receives `url`, `query`, `dom`, optional `taskId`; validates tenant and domain; loads or creates task; runs RAG; builds prompt with **server-held action history**; calls LLM; returns **`NextActionResponse`**. Client executes actions and loops (see `THIN_CLIENT_ROADMAP_CLIENT.md` §4).

**Deliverable:** `POST /api/agent/interact` implements the full loop. Action history lives on the server only; client never sends or maintains history for inference.

---

### 4.1 Persistence for Task 3 (Mongoose)

**No SQL migrations.** Add **Mongoose** models for the action loop. Reuse tenant resolution, `allowed_domains`, and RAG/knowledge from Tasks 1–2.

- **`tasks`** — Mongoose schema in `lib/models/task.ts`. Fields: `taskId` (UUID string, unique), `tenantId`, `userId`, `url`, `query`, `status` (`active` | `completed` | `failed` | `interrupted`), `createdAt`, `updatedAt`. Indexes: `(tenantId, taskId)` unique, `(tenantId, status)`, `(tenantId, userId)`. All accesses scoped by `tenantId`.

- **`task_actions`** — Mongoose schema in `lib/models/task-action.ts`. Fields: `tenantId`, `taskId` (UUID string), `userId`, `stepIndex`, `thought`, `action`, `createdAt`. Unique index on `(tenantId, taskId, stepIndex)`. All accesses scoped by `tenantId` and `taskId`.

---

### 4.2 API Endpoint (Task 3)

- **`POST /api/agent/interact`** — **Implementation:** `app/api/agent/interact/route.ts`  
  - Body: `{ url, query, dom, taskId? }`. Validated with Zod schema (`lib/agent/schemas.ts`).  
  - Auth: Bearer. Resolve `userId`, `tenantId` via `getSessionFromRequest`.  
  - **Active Domain:** `domain = new URL(url).hostname`. **`allowed_domains` as filter (§1.6):** same as Task 2 — **no** 403. If domain matches and we have org-specific knowledge → use org + public RAG; otherwise → **public knowledge only**.  
  - **Task resolution:**  
    - If `taskId` provided: load `tasks` + `task_actions` for `(tenantId, taskId)`. If not found → 404. If `status` is `completed` or `failed` → 409.  
    - If no `taskId`: create row in `tasks` with UUID `taskId` (via `crypto.randomUUID()`); init empty `task_actions`.  
  - **RAG:** Reuse Task 2 logic via shared `getRAGChunks()` helper (`lib/knowledge-extraction/rag-helper.ts`). When org-specific: tenant + domain RAG. When public-only: public knowledge. Inject chunks **into the LLM prompt only**; extension **never** receives raw chunks/citations (§1.5).  
  - **Prompt:** Built via `buildActionPrompt()` (`lib/agent/prompt-builder.ts`). System message (role, actions, `<Thought>`/`<Action>` format) + user message (user `query`, current time, **server-held action history** from `task_actions`, RAG context, current `dom`).  
  - **LLM:** Call OpenAI via `callActionLLM()` (`lib/agent/llm-client.ts`). Reuses existing `OPENAI_API_KEY` from `.env.local`. Parse `<Thought>` and `<Action>` via `parseActionResponse()`. Validate action format (`click`, `setValue`, `finish`, `fail`) via `validateActionFormat()`.  
  - **History:** Append `{ thought, action, stepIndex }` to `task_actions`. If action is `finish()` or `fail()`, update `tasks.status` to `completed` or `failed`.  
  - Response: **`NextActionResponse`** — `{ thought, action, usage?, taskId?, hasOrgKnowledge?: boolean }`.  
    - `hasOrgKnowledge`: `true` when org-specific RAG was used; `false` when only public. Extension shows “no knowledge for this website” dialog when `hasOrgKnowledge === false` (§1.6).  
  - Enforce max steps per task (50); return 400 when exceeded.

**Isolation:** All DB and RAG access scoped by **Tenant ID** when org-specific. **Active Domain** used only as **filter** (when to use org RAG). **Action history** per `taskId` and `tenantId`.

---

### 4.3 Definition of Done / QA Verification (Task 3 — Server)

- [x] Mongoose models `tasks` and `task_actions` exist; **no** SQL migrations. **Implementation:** `lib/models/task.ts`, `lib/models/task-action.ts` with UUID `taskId`, proper indexes.
- [x] `POST /api/agent/interact` returns **200** with `NextActionResponse` for any valid `url` when Bearer valid; creates task when no `taskId`; appends to history and returns same `taskId` on subsequent requests. **No** 403 based on `allowed_domains` (§1.6). **Implementation:** `app/api/agent/interact/route.ts` with OPTIONS + POST handlers.
- [x] Response includes `hasOrgKnowledge`: `true` when org-specific RAG used; `false` when public-only. Extension uses this to show “no knowledge for this website” dialog when applicable.
- [x] Server uses **only** server-held action history for prompt context; no client-supplied history. **Implementation:** History loaded from `task_actions` and injected into prompt via `buildActionPrompt()`.
- [x] RAG and `allowed_domains` filter reuse Task 2 logic; **Tenant ID** and **Active Domain** isolation when org-specific; public-only path when no org knowledge. **Implementation:** Shared `getRAGChunks()` helper in `lib/knowledge-extraction/rag-helper.ts` used by both resolve and interact routes.
- [ ] End-to-end: extension runs multi-step task on **live site**; DOM sent to backend; actions executed; task completes with `finish` or `fail` (see client roadmap). QA verifies history continuity, finish/fail, **no** 403 on domain, 401 when logged out, and correct `hasOrgKnowledge` for org vs public-only.

**Exit criterion:** Task 3 complete when all above are verified. Thin Client backend is fully validated.

---

## 5. Task 4: User Preferences API (Server)

**Objective:** User preferences/settings API endpoint for Chrome extension settings page. Stores user preferences (theme, etc.) per tenant.

**Deliverable:** `GET /api/v1/user/preferences` and `POST /api/v1/user/preferences` endpoints with Bearer token auth, tenant isolation, and CORS support.

---

### 5.1 Persistence for Task 4 (Mongoose)

**New Mongoose model:** `user_preferences`

- **Collection:** `user_preferences` (or equivalent). **Mongoose** schema in `lib/models/user-preference.ts`.
- **Fields:** `tenantId` (string, indexed, unique), `userId` (string, optional), `preferences` (object with `theme: 'light' | 'dark' | 'system'`), `syncedAt` (Date), `createdAt`, `updatedAt` (timestamps).
- **Purpose:** Store user preferences per tenant (user or organization). One preference record per tenant.

**No migrations:** Add the Mongoose schema only.

---

### 5.2 API Endpoints (Task 4)

- **`GET /api/v1/user/preferences`**  
  - Auth: Bearer token.  
  - Resolve `userId`, `tenantId` from token via `getSessionFromRequest()`.  
  - Query `UserPreference` by `tenantId`.  
  - Response: `{ preferences: { theme: string }, syncedAt?: string }`.  
  - If no preferences exist, return defaults: `{ preferences: { theme: 'system' } }`.  
  - 401 if invalid or expired.

- **`POST /api/v1/user/preferences`**  
  - Auth: Bearer token.  
  - Body: `{ theme: 'light' | 'dark' | 'system', clientVersion?: string }`.  
  - Validate request body with Zod schema (`preferencesRequestSchema`).  
  - Upsert `UserPreference` document (findOneAndUpdate with upsert: true).  
  - Response: `{ success: true, preferences: { theme: string }, syncedAt: string }`.  
  - 401 if invalid token; 400 if validation error.

**Shared auth helper:** Reuse `getSessionFromRequest()` from Task 1.

---

### 5.3 Definition of Done / QA Verification (Task 4 — Server)

- [x] Mongoose model `UserPreference` exists with proper indexes (unique on `tenantId`). **Implementation:** `lib/models/user-preference.ts` with `tenantId`, `userId`, `preferences`, `syncedAt`, timestamps.
- [x] `GET /api/v1/user/preferences` returns 200 with preferences or defaults when Bearer valid; 401 without token. **Implementation:** `app/api/v1/user/preferences/route.ts` with GET handler.
- [x] `POST /api/v1/user/preferences` returns 200 with upserted preferences when Bearer valid; 401 without token; 400 on validation error. **Implementation:** `app/api/v1/user/preferences/route.ts` with POST handler.
- [x] Zod schemas and TypeScript types defined. **Implementation:** `lib/api/schemas/preferences.ts` with `preferencesRequestSchema`, `PreferencesRequest`, `PreferencesResponse`.
- [x] CORS configured for extension origin (verified in code - `lib/utils/cors.ts` handles `/api/v1/*` routes).
- [x] Tenant isolation verified (all queries scoped by `tenantId` from session).
- [x] Error handling implemented (401, 400, 500) with Sentry integration.
- [x] Database connection handling added (`connectDB()`).
- [ ] End-to-end: extension can fetch and save preferences (see client roadmap). QA verifies on **live site**.

**Implementation Status:**
- ✅ Mongoose model: `UserPreference` created in `lib/models/user-preference.ts`
  - Fields: `tenantId` (indexed, unique), `userId` (optional), `preferences.theme`, `syncedAt`, timestamps
  - Unique index on `{ tenantId }` for one preference per tenant
- ✅ API routes: `/api/v1/user/preferences` with GET and POST handlers
  - **GET:** Fetches preferences by `tenantId` or returns defaults
  - **POST:** Upserts preferences with Zod validation
  - Both use `getSessionFromRequest()` for auth
  - Both include CORS headers and error handling
- ✅ Zod schemas: `lib/api/schemas/preferences.ts`
  - `preferencesRequestSchema` for validation
  - `PreferencesRequest` and `PreferencesResponse` types
- ✅ Model export: Added to `lib/models/index.ts`

**Exit criterion:** Server-side Task 4 complete when all above are verified. API ready for extension settings page integration.

---

## 6. Task Order and Dependencies

| Order | Task | Depends on | Server delivers |
|-------|------|------------|-----------------|
| **1** | Authentication & API Client | Prerequisites | Login, session, logout APIs; auth helper |
| **2** | Runtime Knowledge Resolution | Task 1 | Resolve API, RAG schema |
| **3** | Server-Side Action Loop | Task 1, Task 2 | Interact API, task/history schema |
| **4** | User Preferences API | Task 1 | Preferences API, user preference model |

- **Task 2** depends on **Task 1** (auth, tenant resolution, `allowed_domains`).  
- **Task 3** depends on **Task 1** (auth) and **Task 2** (RAG schema, domain allowlist, resolve patterns).
- **Task 4** depends on **Task 1** (auth, tenant resolution, `getSessionFromRequest` helper).

---

## 7. References

### 6.1 Internal

- **`SERVER_SIDE_AGENT_ARCH.md`** — Specification: Auth API (§2), interact (§4), resolve (§5), RAG, action history. DB stack & tenant (§1.3), interact vs resolve (§5.6), Extension notes (§10), References (§11). **Keep in sync with this roadmap.**  
- **`THIN_CLIENT_ROADMAP_CLIENT.md`** — Extension integration for Tasks 1–3.  
- **`ARCHITECTURE.md`** — Hybrid DB (Prisma + Mongoose), tenant model (user / organization), multi-tenancy.  
- **`BROWSER_AUTOMATION_RESOLVE_SCHEMA.md`** — **Browser automation / extraction service** `GET /api/knowledge/resolve` request & response schema. Referenced by Task 2 (§3.1, §3.2) and `lib/knowledge-extraction/resolve-client.ts`.

### 6.2 Better Auth

- [Browser Extension Guide](https://www.better-auth.com/docs/guides/browser-extension-guide) — Extension setup, `trustedOrigins`, `host_permissions`, client `createAuthClient` + `baseURL`.  
- [Bearer Token Authentication](https://beta.better-auth.com/docs/plugins/bearer) — `bearer()` plugin, `set-auth-token` header, `fetchOptions.auth: { type: "Bearer", token }`, `getSession` with Bearer.  
- [Options / trustedOrigins](https://www.better-auth.com/docs/reference/options) — `trustedOrigins` config for extension origins.  
- [Integrations / Next](https://better-auth.com/docs/integrations/next) — `toNextJsHandler(auth)`, App Router `/api/auth/[...all]`.

### 6.3 Next.js

- [App Router](https://nextjs.org/docs/app) — App Router overview.  
- [Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware) — CORS, preflight, extension origin.  
- [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) — `NextRequest` / `NextResponse`, API route layout for `/api/v1/*`, `/api/agent/*`, `/api/knowledge/*`.
